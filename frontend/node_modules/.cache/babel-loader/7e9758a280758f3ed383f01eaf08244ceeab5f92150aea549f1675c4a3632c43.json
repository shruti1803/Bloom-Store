{"ast":null,"code":"import utils from '../utils.js';\nimport httpAdapter from './http.js';\nimport xhrAdapter from './xhr.js';\nimport * as fetchAdapter from './fetch.js';\nimport AxiosError from \"../core/AxiosError.js\";\n\n/**\r\n * Known adapters mapping.\r\n * Provides environment-specific adapters for Axios:\r\n * - `http` for Node.js\r\n * - `xhr` for browsers\r\n * - `fetch` for fetch API-based requests\r\n * \r\n * @type {Object<string, Function|Object>}\r\n */\nconst knownAdapters = {\n  http: httpAdapter,\n  xhr: xhrAdapter,\n  fetch: {\n    get: fetchAdapter.getFetch\n  }\n};\n\n// Assign adapter names for easier debugging and identification\nutils.forEach(knownAdapters, (fn, value) => {\n  if (fn) {\n    try {\n      Object.defineProperty(fn, 'name', {\n        value\n      });\n    } catch (e) {\n      // eslint-disable-next-line no-empty\n    }\n    Object.defineProperty(fn, 'adapterName', {\n      value\n    });\n  }\n});\n\n/**\r\n * Render a rejection reason string for unknown or unsupported adapters\r\n * \r\n * @param {string} reason\r\n * @returns {string}\r\n */\nconst renderReason = reason => `- ${reason}`;\n\n/**\r\n * Check if the adapter is resolved (function, null, or false)\r\n * \r\n * @param {Function|null|false} adapter\r\n * @returns {boolean}\r\n */\nconst isResolvedHandle = adapter => utils.isFunction(adapter) || adapter === null || adapter === false;\n\n/**\r\n * Get the first suitable adapter from the provided list.\r\n * Tries each adapter in order until a supported one is found.\r\n * Throws an AxiosError if no adapter is suitable.\r\n * \r\n * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.\r\n * @param {Object} config - Axios request configuration\r\n * @throws {AxiosError} If no suitable adapter is available\r\n * @returns {Function} The resolved adapter function\r\n */\nfunction getAdapter(adapters, config) {\n  adapters = utils.isArray(adapters) ? adapters : [adapters];\n  const {\n    length\n  } = adapters;\n  let nameOrAdapter;\n  let adapter;\n  const rejectedReasons = {};\n  for (let i = 0; i < length; i++) {\n    nameOrAdapter = adapters[i];\n    let id;\n    adapter = nameOrAdapter;\n    if (!isResolvedHandle(nameOrAdapter)) {\n      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\n      if (adapter === undefined) {\n        throw new AxiosError(`Unknown adapter '${id}'`);\n      }\n    }\n    if (adapter && (utils.isFunction(adapter) || (adapter = adapter.get(config)))) {\n      break;\n    }\n    rejectedReasons[id || '#' + i] = adapter;\n  }\n  if (!adapter) {\n    const reasons = Object.entries(rejectedReasons).map(([id, state]) => `adapter ${id} ` + (state === false ? 'is not supported by the environment' : 'is not available in the build'));\n    let s = length ? reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0]) : 'as no adapter specified';\n    throw new AxiosError(`There is no suitable adapter to dispatch the request ` + s, 'ERR_NOT_SUPPORT');\n  }\n  return adapter;\n}\n\n/**\r\n * Exports Axios adapters and utility to resolve an adapter\r\n */\nexport default {\n  /**\r\n   * Resolve an adapter from a list of adapter names or functions.\r\n   * @type {Function}\r\n   */\n  getAdapter,\n  /**\r\n   * Exposes all known adapters\r\n   * @type {Object<string, Function|Object>}\r\n   */\n  adapters: knownAdapters\n};","map":{"version":3,"names":["utils","httpAdapter","xhrAdapter","fetchAdapter","AxiosError","knownAdapters","http","xhr","fetch","get","getFetch","forEach","fn","value","Object","defineProperty","e","renderReason","reason","isResolvedHandle","adapter","isFunction","getAdapter","adapters","config","isArray","length","nameOrAdapter","rejectedReasons","i","id","String","toLowerCase","undefined","reasons","entries","map","state","s","join"],"sources":["C:/Users/Hp/bloom-store/frontend/node_modules/axios/lib/adapters/adapters.js"],"sourcesContent":["import utils from '../utils.js';\r\nimport httpAdapter from './http.js';\r\nimport xhrAdapter from './xhr.js';\r\nimport * as fetchAdapter from './fetch.js';\r\nimport AxiosError from \"../core/AxiosError.js\";\r\n\r\n/**\r\n * Known adapters mapping.\r\n * Provides environment-specific adapters for Axios:\r\n * - `http` for Node.js\r\n * - `xhr` for browsers\r\n * - `fetch` for fetch API-based requests\r\n * \r\n * @type {Object<string, Function|Object>}\r\n */\r\nconst knownAdapters = {\r\n  http: httpAdapter,\r\n  xhr: xhrAdapter,\r\n  fetch: {\r\n    get: fetchAdapter.getFetch,\r\n  }\r\n};\r\n\r\n// Assign adapter names for easier debugging and identification\r\nutils.forEach(knownAdapters, (fn, value) => {\r\n  if (fn) {\r\n    try {\r\n      Object.defineProperty(fn, 'name', { value });\r\n    } catch (e) {\r\n      // eslint-disable-next-line no-empty\r\n    }\r\n    Object.defineProperty(fn, 'adapterName', { value });\r\n  }\r\n});\r\n\r\n/**\r\n * Render a rejection reason string for unknown or unsupported adapters\r\n * \r\n * @param {string} reason\r\n * @returns {string}\r\n */\r\nconst renderReason = (reason) => `- ${reason}`;\r\n\r\n/**\r\n * Check if the adapter is resolved (function, null, or false)\r\n * \r\n * @param {Function|null|false} adapter\r\n * @returns {boolean}\r\n */\r\nconst isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;\r\n\r\n/**\r\n * Get the first suitable adapter from the provided list.\r\n * Tries each adapter in order until a supported one is found.\r\n * Throws an AxiosError if no adapter is suitable.\r\n * \r\n * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.\r\n * @param {Object} config - Axios request configuration\r\n * @throws {AxiosError} If no suitable adapter is available\r\n * @returns {Function} The resolved adapter function\r\n */\r\nfunction getAdapter(adapters, config) {\r\n  adapters = utils.isArray(adapters) ? adapters : [adapters];\r\n\r\n  const { length } = adapters;\r\n  let nameOrAdapter;\r\n  let adapter;\r\n\r\n  const rejectedReasons = {};\r\n\r\n  for (let i = 0; i < length; i++) {\r\n    nameOrAdapter = adapters[i];\r\n    let id;\r\n\r\n    adapter = nameOrAdapter;\r\n\r\n    if (!isResolvedHandle(nameOrAdapter)) {\r\n      adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];\r\n\r\n      if (adapter === undefined) {\r\n        throw new AxiosError(`Unknown adapter '${id}'`);\r\n      }\r\n    }\r\n\r\n    if (adapter && (utils.isFunction(adapter) || (adapter = adapter.get(config)))) {\r\n      break;\r\n    }\r\n\r\n    rejectedReasons[id || '#' + i] = adapter;\r\n  }\r\n\r\n  if (!adapter) {\r\n    const reasons = Object.entries(rejectedReasons)\r\n      .map(([id, state]) => `adapter ${id} ` +\r\n        (state === false ? 'is not supported by the environment' : 'is not available in the build')\r\n      );\r\n\r\n    let s = length ?\r\n      (reasons.length > 1 ? 'since :\\n' + reasons.map(renderReason).join('\\n') : ' ' + renderReason(reasons[0])) :\r\n      'as no adapter specified';\r\n\r\n    throw new AxiosError(\r\n      `There is no suitable adapter to dispatch the request ` + s,\r\n      'ERR_NOT_SUPPORT'\r\n    );\r\n  }\r\n\r\n  return adapter;\r\n}\r\n\r\n/**\r\n * Exports Axios adapters and utility to resolve an adapter\r\n */\r\nexport default {\r\n  /**\r\n   * Resolve an adapter from a list of adapter names or functions.\r\n   * @type {Function}\r\n   */\r\n  getAdapter,\r\n\r\n  /**\r\n   * Exposes all known adapters\r\n   * @type {Object<string, Function|Object>}\r\n   */\r\n  adapters: knownAdapters\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}